Реализовать вечный цикл, где:
- 1 шаг = 0.1 секунда
- Первые 100 шагов каждый шаг стартовать новый поток, который бесконечно сидит в sleep
- Вторые 100 шагов каждый шаг убивать один из стартованных поток из шага выше
- 
- Сделать метод a(), который делает sleep 1 секунду, потом вызывает a1(), который делает sleep 2 секунды и вызывает a2(), который делает sleep 3 секунды
- Сделать метод b(), похожий на a, только вместо sleep - цикл 100 тыс. умножений на рандом. Не забыть про yield в цикле.
- В самом начале запустить два потока, которые каждую секунду вызывают эти методы a() и b()

Остановиться на breakpoint-е и показать в дебаггере:
- путь исполнения по каскаду вызовов
- переключиться между потоками при остановке исполнения
- содержимое памяти при остановке
- сделать шаг внутрь, вовне и далее

Показать в профилировщике:
- Количество потоков в конкретный момент времени
- Какие объекты аллоцируются
- Сколько времени тратится на потоках a() и b() - на конкретных методах из каскада

Взять присланный файл ProfilerPuzzle, запустить его с параметром "<username студента>" и угадать, сколько времени ждут методы A, B и C, если:
- A ждет T1 условных единиц и вызывает B
- B ждет T2 условных единиц и вызывает C
- С ждет T3 условных единиц и вызывает D
- D ждет 1 условную единицу
- Важно: Нужно опираться на total times, а не self times
  Нужно узнать T1, T2, T3

Сссылка: https://www.ej-technologies.com/products/jprofiler/overview.html
